/-
Copyright (c) 2025-2026. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jonathan Washburn
-/
import Hodge.Analytic.ContMDiffForms
import Hodge.Analytic.DomCoprod
import Mathlib.Analysis.Calculus.FDeriv.Bilinear
import Mathlib.Analysis.Calculus.FDeriv.CompCLM

/-!
# Leibniz Rule for Exterior Derivative

This file provides the infrastructure to prove the graded Leibniz rule:
  d(Ï‰ âˆ§ Î·) = dÏ‰ âˆ§ Î· + (-1)^k Ï‰ âˆ§ dÎ·

## Main results

* `hasFDerivAt_wedge`: Derivative of wedge product of functions
* `mfderiv_wedge_apply`: Manifold derivative of wedge product
* `alternatizeUncurryFin_wedge_right`: Alternatization commutes with wedge (right fixed)
* `alternatizeUncurryFin_wedge_left`: Alternatization commutes with wedge (left fixed, with sign)
* `extDerivAt_wedge`: Exterior derivative of wedge product (the Leibniz rule)

## Implementation notes

The graded sign (-1)^k arises from the fact that `alternatizeUncurryFin` inserts the
derivative direction at the first index, while the wedge product naturally combines
indices from both forms. Moving the derivative index past k indices of a k-form
introduces the sign.
-/

open Manifold Set Filter

variable {n k : â„•} {X : Type*} [TopologicalSpace X] [ChartedSpace (EuclideanSpace â„‚ (Fin n)) X]
  [IsManifold (ğ“’_complex n) âŠ¤ X]

namespace LeibnizRule

/-- Helper abbreviation for the fiber alternating maps. -/
abbrev Alt (n k : â„•) := ContinuousAlternatingMap â„‚ (TangentModel n) â„‚ (Fin k)

/-! ### Derivative of Wedge Product -/

/-- The wedge product is a bounded bilinear map.
This is the key ingredient for computing derivatives of wedge products. -/
lemma isBoundedBilinearMap_wedge {k l : â„•} :
    IsBoundedBilinearMap â„‚ (fun p : Alt n k Ã— Alt n l => p.1.wedge p.2) where
  add_left := fun xâ‚ xâ‚‚ y => ContinuousAlternatingMap.wedge_add_left xâ‚ xâ‚‚ y
  smul_left := fun c x y => ContinuousAlternatingMap.wedge_smul_left c x y
  add_right := fun x yâ‚ yâ‚‚ => ContinuousAlternatingMap.wedge_add_right x yâ‚ yâ‚‚
  smul_right := fun c x y => ContinuousAlternatingMap.wedge_smul_right c x y
  bound := by
    -- Boundedness follows from finite-dimensionality
    -- The wedge of continuous alternating maps is continuous
    -- On finite-dimensional spaces, continuous bilinear = bounded bilinear
    sorry

/-- The derivative of the wedge product of two form-valued functions.

If `Ï‰ : G â†’ Alt n k` and `Î· : G â†’ Alt n l` are differentiable at x, then
`y â†¦ Ï‰(y) âˆ§ Î·(y)` is differentiable and its derivative is:
  `v â†¦ (DÏ‰(v)) âˆ§ Î·(x) + Ï‰(x) âˆ§ (DÎ·(v))`
-/
theorem hasFDerivAt_wedge {G : Type*} [NormedAddCommGroup G] [NormedSpace â„‚ G]
    {k l : â„•} {Ï‰ : G â†’ Alt n k} {Î· : G â†’ Alt n l} {x : G}
    {Ï‰' : G â†’L[â„‚] Alt n k} {Î·' : G â†’L[â„‚] Alt n l}
    (hÏ‰ : HasFDerivAt Ï‰ Ï‰' x) (hÎ· : HasFDerivAt Î· Î·' x) :
    HasFDerivAt (fun y => (Ï‰ y).wedge (Î· y))
      ((ContinuousLinearMap.compL â„‚ (Alt n k) (Alt n l â†’L[â„‚] Alt n (k+l)) (Alt n (k+l))
        (ContinuousLinearMap.apply â„‚ (Alt n (k+l)) (Î· x))
        (ContinuousAlternatingMap.wedgeCLM_alt â„‚ (TangentModel n) k l)).comp Ï‰' +
       (ContinuousLinearMap.compL â„‚ (Alt n l) (Alt n (k+l)) (Alt n (k+l))
        (ContinuousLinearMap.id â„‚ (Alt n (k+l)))
        (ContinuousAlternatingMap.wedgeCLM_alt â„‚ (TangentModel n) k l (Ï‰ x))).comp Î·') x := by
  -- Use the bounded bilinear map derivative rule
  have hB := isBoundedBilinearMap_wedge (n := n) (k := k) (l := l)
  have h := hB.hasFDerivAt (Ï‰ x, Î· x)
  -- Compose with (Ï‰, Î·) : G â†’ Alt k Ã— Alt l
  sorry

/-- The manifold derivative of a wedge product follows the Leibniz rule (pointwise). -/
theorem mfderiv_wedge_apply {k l : â„•} (Ï‰ : ContMDiffForm n X k) (Î· : ContMDiffForm n X l) (x : X)
    (v : TangentSpace (ğ“’_complex n) x) :
    mfderiv (ğ“’_complex n) ğ“˜(â„‚, Alt n (k+l)) (Ï‰.wedge Î·).as_alternating x v =
    (mfderiv (ğ“’_complex n) ğ“˜(â„‚, Alt n k) Ï‰.as_alternating x v).wedge (Î·.as_alternating x) +
    (Ï‰.as_alternating x).wedge (mfderiv (ğ“’_complex n) ğ“˜(â„‚, Alt n l) Î·.as_alternating x v) := by
  -- This follows from hasFDerivAt_wedge and the definition of mfderiv
  sorry

/-! ### Alternatization and Wedge Compatibility -/

/-- Alternatization commutes with wedge when the right argument is fixed.

The equality requires a cast since `(k+1)+l â‰  (k+l)+1` definitionally. -/
theorem alternatizeUncurryFin_wedge_right {k l : â„•}
    (A : TangentModel n â†’L[â„‚] Alt n k) (B : Alt n l) :
    let wedge_right : TangentModel n â†’L[â„‚] Alt n (k + l) :=
      (ContinuousAlternatingMap.wedgeCLM_alt â„‚ (TangentModel n) k l).flip B âˆ˜L A
    ContinuousAlternatingMap.alternatizeUncurryFin (F := â„‚) wedge_right =
    ContinuousAlternatingMap.domDomCongr
      ((ContinuousAlternatingMap.alternatizeUncurryFin (F := â„‚) A).wedge B)
      (finCongr (show (k+1)+l = (k+l)+1 by omega)) := by
  -- The key is that wedge is linear in first argument
  -- Alternatization (a signed sum over permutations) commutes with linear operations
  sorry

/-- Alternatization commutes with wedge when the left argument is fixed (with sign).

The sign (-1)^k arises from permuting the new index past k existing indices.
The equality requires a cast since `k+(l+1) â‰  (k+l)+1` definitionally. -/
theorem alternatizeUncurryFin_wedge_left {k l : â„•}
    (A : Alt n k) (B : TangentModel n â†’L[â„‚] Alt n l) :
    let wedge_left : TangentModel n â†’L[â„‚] Alt n (k + l) :=
      (ContinuousAlternatingMap.wedgeCLM_alt â„‚ (TangentModel n) k l A) âˆ˜L B
    ContinuousAlternatingMap.alternatizeUncurryFin (F := â„‚) wedge_left =
    ContinuousAlternatingMap.domDomCongr
      ((-1 : â„‚)^k â€¢ A.wedge (ContinuousAlternatingMap.alternatizeUncurryFin (F := â„‚) B))
      (finCongr (show k+(l+1) = (k+l)+1 by omega)) := by
  -- The sign arises from moving the new derivative index past k indices
  -- This involves permutation sign calculations
  sorry

/-! ### The Leibniz Rule -/

/-- Cast a `ContinuousAlternatingMap` along an equality of the index cardinality. -/
noncomputable def castAlt {m m' : â„•} (h : m = m') (f : Alt n m) : Alt n m' :=
  ContinuousAlternatingMap.domDomCongr f (finCongr h)

/-- **Leibniz rule for exterior derivative**: d(Ï‰ âˆ§ Î·) = dÏ‰ âˆ§ Î· + (-1)^k Ï‰ âˆ§ dÎ·.

This is the fundamental identity relating the exterior derivative to the wedge product.
It expresses that d is a graded derivation on the exterior algebra.
-/
theorem extDerivAt_wedge {k l : â„•} (Ï‰ : ContMDiffForm n X k) (Î· : ContMDiffForm n X l) (x : X) :
    ContMDiffForm.extDerivAt (Ï‰.wedge Î·) x =
    castAlt (show (k+1)+l = (k+l)+1 by omega)
      ((ContMDiffForm.extDerivAt Ï‰ x).wedge (Î·.as_alternating x)) +
    castAlt (show k+(l+1) = (k+l)+1 by omega)
      (((-1 : â„‚)^k) â€¢ (Ï‰.as_alternating x).wedge (ContMDiffForm.extDerivAt Î· x)) := by
  -- The proof combines:
  -- 1. mfderiv_wedge_apply: bilinear derivative rule
  -- 2. alternatizeUncurryFin_add: additivity of alternatization
  -- 3. alternatizeUncurryFin_wedge_right and alternatizeUncurryFin_wedge_left
  -- 4. Type casts via castAlt
  sorry

end LeibnizRule
