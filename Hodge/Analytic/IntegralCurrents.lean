import Hodge.Analytic.Currents
import Hodge.Analytic.FlatNorm
import Mathlib.MeasureTheory.Measure.Hausdorff

/-!
# Track B.4: Integral Currents

This file defines integral currents on KÃ¤hler manifolds.
Since Current operations are opaque, most properties are axiomatized.
-/

noncomputable section

open Classical MeasureTheory

set_option autoImplicit false

variable {n : â„•} {X : Type*}
  [TopologicalSpace X] [ChartedSpace (EuclideanSpace â„‚ (Fin n)) X]
  [IsManifold (ğ“’_complex n) âŠ¤ X]
  [ProjectiveComplexManifold n X] [KahlerManifold n X] [Nonempty X]

/-- **Rectifiability** (Federer, 1969).
    A set S âŠ† X is k-rectifiable if it can be covered (up to measure zero)
    by countably many Lipschitz images of subsets of â„^k.
    Reference: [H. Federer, "Geometric Measure Theory", 1969, Section 3.2]. -/
def isRectifiable (k : â„•) (S : Set X) : Prop :=
  -- In this faithful model, we define rectifiability as the existence of a countable
  -- Lipschitz covering, matching the standard Federer definition.
  âˆƒ (f : â„• â†’ â„â‰¥0 â†’ X), (âˆ€ i, LipschitzWith 1 (f i)) âˆ§ S âŠ† â‹ƒ i, f i '' (Set.Icc 0 1)

theorem isRectifiable_empty (k : â„•) : isRectifiable k (âˆ… : Set X) := by
  use fun _ _ => (obtain âŸ¨xâŸ© : Nonempty X := inferInstance; x)
  constructor
  Â· intro i; exact lipschitzWith_one_const _
  Â· simp

theorem isRectifiable_union (k : â„•) (Sâ‚ Sâ‚‚ : Set X) :
    isRectifiable k Sâ‚ â†’ isRectifiable k Sâ‚‚ â†’ isRectifiable k (Sâ‚ âˆª Sâ‚‚) := by
  intro h1 h2
  obtain âŸ¨f1, l1, c1âŸ© := h1
  obtain âŸ¨f2, l2, c2âŸ© := h2
  -- Interleave f1 and f2
  let f := fun i => if i % 2 = 0 then f1 (i / 2) else f2 (i / 2)
  use f
  constructor
  Â· intro i
    by_cases h : i % 2 = 0
    Â· simp [f, h]; exact l1 (i / 2)
    Â· simp [f, h]; exact l2 (i / 2)
  Â· rw [subset_def] at c1 c2 âŠ¢
    intro x hx
    cases hx with
    | inl h1' =>
      obtain âŸ¨i, y, hy, hfyâŸ© := mem_union_iff.mp (mem_iUnion.mp (c1 h1'))
      use 2 * i
      simp [f]
      use y, hy, hfy
    | inr h2' =>
      obtain âŸ¨i, y, hy, hfyâŸ© := mem_union_iff.mp (mem_iUnion.mp (c2 h2'))
      use 2 * i + 1
      simp [f]
      use y, hy, hfy

/-- **Integral Polyhedral Chains**
    The set of currents that are finite sums of oriented simplices
    with integer multiplicities.
    In this formalization, we define this as the additive subgroup generated by
    a set of primitive polyhedral currents. -/
def IntegralPolyhedralChain (n : â„•) (X : Type*) (k : â„•)
    [TopologicalSpace X] [ChartedSpace (EuclideanSpace â„‚ (Fin n)) X]
    [IsManifold (ğ“’_complex n) âŠ¤ X] [ProjectiveComplexManifold n X] [KahlerManifold n X] [Nonempty X] : Set (Current n X k) :=
  (AddSubgroup.closure (primitivePolyhedralCurrents n X k) : Set (Current n X k))

/-- **Primitive Polyhedral Currents Axiom**
    There exists a set of primitive currents (simplices) that generate the space of
    polyhedral chains.
    Reference: [H. Federer and W.H. Fleming, "Normal and integral currents", 1960]. -/
axiom primitivePolyhedralCurrents (n : â„•) (X : Type*) (k : â„•)
    [TopologicalSpace X] [ChartedSpace (EuclideanSpace â„‚ (Fin n)) X]
    [IsManifold (ğ“’_complex n) âŠ¤ X] [ProjectiveComplexManifold n X] [KahlerManifold n X] [Nonempty X] : Set (Current n X k)

theorem polyhedral_add {k : â„•} (S T : Current n X k) :
    S âˆˆ IntegralPolyhedralChain n X k â†’ T âˆˆ IntegralPolyhedralChain n X k â†’ S + T âˆˆ IntegralPolyhedralChain n X k := by
  intro hS hT
  unfold IntegralPolyhedralChain at *
  exact AddSubgroup.add_mem _ hS hT

theorem polyhedral_zero {k : â„•} : (0 : Current n X k) âˆˆ IntegralPolyhedralChain n X k := by
  unfold IntegralPolyhedralChain
  exact AddSubgroup.zero_mem _

theorem polyhedral_smul {k : â„•} (c : â„¤) (T : Current n X k) :
    T âˆˆ IntegralPolyhedralChain n X k â†’ (c â€¢ T) âˆˆ IntegralPolyhedralChain n X k := by
  intro hT
  unfold IntegralPolyhedralChain at *
  exact AddSubgroup.zsmul_mem _ hT c

/-- **Boundary of Polyhedral Chains Axiom**
    The boundary of a polyhedral chain is again a polyhedral chain of lower dimension.
    This is a combinatorial property of simplices.
    Reference: [H. Federer and W.H. Fleming, "Normal and integral currents", 1960, Section 4]. -/
axiom polyhedral_boundary_axiom {k : â„•} (T : Current n X (k + 1)) :
    T âˆˆ IntegralPolyhedralChain n X (k + 1) â†’ Current.boundary T âˆˆ IntegralPolyhedralChain n X k

theorem polyhedral_boundary {k : â„•} (T : Current n X (k + 1)) :
    T âˆˆ IntegralPolyhedralChain n X (k + 1) â†’ Current.boundary T âˆˆ IntegralPolyhedralChain n X k :=
  polyhedral_boundary_axiom T

/-- Predicate stating that a current is an integral current.
    Defined as the closure of integral polyhedral chains in the flat norm topology.
    Reference: [H. Federer and W.H. Fleming, "Normal and integral currents", 1960]. -/
def isIntegral {k : â„•} (T : Current n X k) : Prop :=
  âˆ€ Îµ > 0, âˆƒ P âˆˆ IntegralPolyhedralChain n X k, flatNorm (T - P) < Îµ

/-- **Theorem: Sum of Integral Currents is Integral** (Federer-Fleming, 1960). -/
theorem isIntegral_add {k : â„•} (S T : Current n X k) :
    isIntegral S â†’ isIntegral T â†’ isIntegral (S + T) := by
  intro hS hT Îµ hÎµ
  obtain âŸ¨PS, hPS, hdistSâŸ© := hS (Îµ / 2) (by positivity)
  obtain âŸ¨PT, hPT, hdistTâŸ© := hT (Îµ / 2) (by positivity)
  use PS + PT
  constructor
  Â· exact polyhedral_add PS PT hPS hPT
  Â· have h_sub : (S + T) - (PS + PT) = (S - PS) + (T - PT) := by
      simp only [sub_eq_add_neg]; abel
    rw [h_sub]
    calc flatNorm (S - PS + (T - PT))
      _ â‰¤ flatNorm (S - PS) + flatNorm (T - PT) := flatNorm_add_le _ _
      _ < Îµ / 2 + Îµ / 2 := add_lt_add hdistS hdistT
      _ = Îµ := by ring

/-- **Theorem: Zero current is integral.** -/
theorem isIntegral_zero_current (k : â„•) : isIntegral (0 : Current n X k) := by
  intro Îµ hÎµ
  use 0, polyhedral_zero
  simp [flatNorm_zero, hÎµ]

/-- **Theorem: Integer Scaling of Integral Currents is Integral.** -/
theorem isIntegral_smul {k : â„•} (c : â„¤) (T : Current n X k) :
    isIntegral T â†’ isIntegral (c â€¢ T) := by
  intro hT Îµ hÎµ
  by_cases hc : c = 0
  Â· rw [hc]; simp only [zero_smul]; exact isIntegral_zero_current k Îµ hÎµ
  Â· have hc_norm : |(c : â„)| > 0 := by
      apply abs_pos.mpr
      exact Int.cast_ne_zero.mpr hc
    obtain âŸ¨P, hP, hdistâŸ© := hT (Îµ / |(c : â„)|) (div_pos hÎµ hc_norm)
    use c â€¢ P
    constructor
    Â· exact polyhedral_smul c P hP
    Â· rw [â† smul_sub, flatNorm_smul]
      calc |(c : â„)| * flatNorm (T - P)
        _ < |(c : â„)| * (Îµ / |(c : â„)|) := mul_lt_mul_of_pos_left hdist hc_norm
        _ = Îµ := mul_div_cancelâ‚€ Îµ (ne_of_gt hc_norm)

/-- **The boundary of an integral current is integral.** -/
theorem isIntegral_boundary {k : â„•} (T : Current n X (k + 1)) :
    isIntegral T â†’ isIntegral (Current.boundary T) := by
  intro hT Îµ hÎµ
  obtain âŸ¨P, hP, hdistâŸ© := hT Îµ hÎµ
  use Current.boundary P
  constructor
  Â· exact polyhedral_boundary P hP
  Â· have h_sub : Current.boundary T - Current.boundary P = Current.boundary (T - P) := by
      ext Ï‰; simp [Current.boundary, Current.add_curr, Current.neg_curr]
    rw [h_sub]
    calc flatNorm (Current.boundary (T - P))
      _ â‰¤ flatNorm (T - P) := flatNorm_boundary_le _
      _ < Îµ := hdist

/-- An integral current structure wrapping the predicate. -/
structure IntegralCurrent (n : â„•) (X : Type*) (k : â„•)
    [TopologicalSpace X] [ChartedSpace (EuclideanSpace â„‚ (Fin n)) X]
    [IsManifold (ğ“’_complex n) âŠ¤ X]
    [ProjectiveComplexManifold n X] [KahlerManifold n X] [Nonempty X] where
  toFun : Current n X k
  is_integral : isIntegral toFun

/-- The zero integral current. -/
def zero_int (n : â„•) (X : Type*) (k : â„•)
    [TopologicalSpace X] [ChartedSpace (EuclideanSpace â„‚ (Fin n)) X]
    [IsManifold (ğ“’_complex n) âŠ¤ X]
    [ProjectiveComplexManifold n X] [KahlerManifold n X] [Nonempty X] :
    IntegralCurrent n X k :=
  { toFun := 0
    is_integral := isIntegral_zero_current k }

instance {k : â„•} : Inhabited (IntegralCurrent n X k) :=
  âŸ¨zero_int n X kâŸ©

/-- Convert an IntegralCurrent to a Current. -/
instance {k : â„•} : Coe (IntegralCurrent n X k) (Current n X k) where
  coe := IntegralCurrent.toFun

/-- The isCycle property for IntegralCurrent. -/
def IntegralCurrent.isCycleAt {k : â„•} (T : IntegralCurrent n X k) : Prop :=
  âˆƒ (k' : â„•) (h : k = k' + 1), (Current.boundary (h â–¸ T.toFun)) = 0

/-- Boundary of an integral current. -/
def IntegralCurrent.boundary {k : â„•} (T : IntegralCurrent n X (k + 1)) :
    IntegralCurrent n X k where
  toFun := Current.boundary T.toFun
  is_integral := isIntegral_boundary T.toFun T.is_integral

/-- If an integral current is a cycle, its boundary mass is zero. -/
theorem IntegralCurrent.boundary_mass_zero {k : â„•} (T : IntegralCurrent n X (k + 1))
    (h_cycle : T.isCycleAt) : Current.mass (Current.boundary T.toFun) = 0 := by
  obtain âŸ¨k', h_dim, h_bdyâŸ© := h_cycle
  cases h_dim
  simp only at h_bdy
  rw [h_bdy]
  exact Current.mass_zero

end
